# -*- coding: utf-8 -*-
"""IDA_star.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f9R9axN4frDCcKRX8Q8Rrsx72zpPnXNO

https://stackoverflow.com/questions/66264958/how-can-i-implement-ida-algorithm-in-python-for-15-puzzle-problem
"""

import math
import numpy as np
import json
from copy import deepcopy

import sys
sys.setrecursionlimit(10000)

"""
def h(node):
    '''Estimated remaining time of the node-schedule for reaching a terminal node.
    Must understimate true value.'''
    if node.is_terminal():
        return 0
    return (node.number_tasks_remaining()-1) * 2743
    #return (node.number_tasks_remaining()) * min([node.cost(n) for n in node.succ()]) * 0.7
"""


def n2letter(n):
    '''0 to 'a', 1 to 'b', ... '''
    return chr(96+n)


def string2duration(string):
    ''' "01:50:19.3177493" to duration in seconds'''
    return 3600*int(string[:2]) + 60*int(string[3:5]) + int(string[6:8])  # Duration is int


n_cores = 4


def read_data(path):
    global task_count
    global tasks
    file = open(path)
    data = json.load(file)
    nodes = data['nodes']
    tasks = dict()
    for task_str, info in nodes.items():
        task = int(task_str)
        tasks[task] = {'Data': string2duration(
            info['Data']), 'Dependencies': info['Dependencies']}
    task_count = len(tasks)
    print("Data loaded successfully. Number of tasks: " + str(task_count))


read_data("D:/CentraleSupélec/Projet Aneo/Graphs/smallRandom.json")
tasks

# Tasks to child tasks / Tasks to parents / Task is terminal / Task is inital
task2childs = {task: list() for task in tasks}
task2parents = {task: list() for task in tasks}
for task, info in tasks.items():
    # Add childs
    list_task_parents = info['Dependencies']
    for task_parent in list_task_parents:
        task2childs[task_parent].append(task)
    # Add parents
    task2parents[task] = tasks[task]['Dependencies']


def task_is_terminal(task: int):
    return len(task2childs[task]) == 0


def task_is_inital(task: int):
    return len(task2parents[task]) == 0


task2sbl = {}


def save_static_bottom_level(task: int):
    task_duration = tasks[task]["Data"]
    if task_is_terminal(task):
        sbl = task_duration
    else:
        list_sbl_child = list()
        for task_child in task2childs[task]:
            if task_child in task2sbl:
                sbl_child = task2sbl[task_child]
            else:
                sbl_child = save_static_bottom_level(task_child)
            list_sbl_child.append(sbl_child)
        sbl = max(list_sbl_child) + task_duration

    task2sbl[task] = sbl
    return sbl


for task in tasks:
    if task_is_inital(task):
        save_static_bottom_level(task)


class Core():
    def __init__(self, core_n):
        self.core_n = core_n
        self.task = -1
        self.task_end_time = 0

    def __repr__(self):
        return f"({self.core_n}: task {self.task} end at {self.task_end_time})"

    def __eq__(self, node):
        return self.task == node.task and self.task_end_time == node.task_end_time


class Node():  # NEW
    def __init__(self, parent=None, task_to_add=None, core_where_to_add=None, time_task_start=None):
        '''Create a Node object ie a partial scheduling
        parent = parent Node, None if root
        task_to_add : task added to the partial schedule
        core_where_to_add : core where to do task
        time_task_start : instant where the core will start computing the task
        '''
        self.tasks_graph = tasks

        if parent is None:
            self.parent = None
            self.tasks_done = set()
            self.cores = {core_n: {"task": -1, "task_end_time": 0}
                          for core_n in range(n_cores)}

            self.hist = ''

        else:
            self.parent = parent
            self.tasks_done = deepcopy(parent.tasks_done)
            self.tasks_done.add(task_to_add)

            self.cores = deepcopy(parent.cores)
            duration_task = self.tasks_graph[task_to_add]['Data']
            self.cores[core_where_to_add] = {
                "task": task_to_add, "task_end_time": time_task_start + duration_task}

            self.hist = parent.hist + \
                f"|{core_where_to_add}{n2letter(task_to_add)}"

    def __repr__(self):
        string = '[' + ','.join([n2letter(task)
                                for task in self.tasks_done]) + ']'
        string += ''.join(
            [f"({core['task']} end at {core['task_end_time']})" for core in self.cores.values()])
        return string

    def is_terminal(self):
        '''Return whether a node is a full schedule'''
        return len(self.tasks_done) == task_count

    def number_tasks_remaining(self):
        return task_count - len(self.tasks_done_time)

    def succ(self):
        '''Create and return list of child node of self'''
        childs = list()

        # On regarde toutes les tâches qu'on va tenter de rajouter
        for task, info in self.tasks_graph.items():

            # On passe les taches déjà ajoutées
            if task in self.tasks_done:
                continue

            # On ne garde que les taches dont toutes les dépendances ont été réalisées
            if not all([task_required in self.tasks_done for task_required in info['Dependencies']]):
                continue

            # On calcul le temps ou toutes les dépendances de task seront terminés par les coeurs
            time_all_dependencies_done = 0
            for core in self.cores.values():
                # Pour chaque coeur, si la task actuellement calculée est une dépendance, on ne pourra commencer à calculer la nouvelle task qu'une fois que la task dépendante sera finie
                if core["task"] in info['Dependencies']:
                    time_all_dependencies_done = max(
                        core["task_end_time"], time_all_dependencies_done)

            for core_n, core in self.cores.items():
                # On ne commence à faire la task que lorsque toutes les dépendances sont calculées et que le core est disponible.
                time_core_available = core["task_end_time"]
                time_task_start = max(
                    time_all_dependencies_done, time_core_available)
                child = Node(parent=self, task_to_add=task,
                             core_where_to_add=core_n, time_task_start=time_task_start)
                childs.append(child)

        return childs

    def cost(self, child_node):
        '''Return the cost of going from self to child_node, a child node of self
        '''
        g_self = max([core["task_end_time"] for core in self.cores.values()])
        g_child = max([core["task_end_time"]
                      for core in child_node.cores.values()])
        cost = g_child - g_self
        return cost

    # Node-schedule method
    def __eq__(self, node):
        '''Return whether a node is equal to another. Two nodes are considered equal if they have completed the same tasks and if all their cores stop working at same time.
        '''
        return self.tasks_done == node.tasks_done and self.set_of_core() == node.set_of_core()

    def set_of_core(self):
        return set([(core["task"], core["task_end_time"]) for core in self.cores.values()])

    def compute_g(self):
        return max([core["task_end_time"] for core in self.cores.values()])


def h(node):
    '''Estimated remaining time of the node-schedule for reaching a terminal node.
    Must understimate true value.'''
    successor_tasks = list()
    for task, info in tasks.items():
        if task in node.tasks_done:  # On passe les taches déjà ajoutées
            continue
        # On ne garde que les taches dont toutes les dépendances ont été réalisées
        if not all([task_required in node.tasks_done for task_required in info['Dependencies']]):
            continue
        successor_tasks.append(task)
    if successor_tasks == []:
        return 0
    return max([task2sbl[task] for task in successor_tasks])


def IDA(initial_node):

    threshold = h(initial_node)

    #print("heuristic threshold: {}".format(threshold))

    loop_counter = 0

    while 1:
        path = [initial_node]  # à optimiser

        tmp = search(initial_node, 0, threshold, path)

        #print("tmp: {}".format(tmp))
        if tmp == True:
            return path, threshold
        elif tmp == float('inf'):
            return False, float('inf')
        else:
            threshold = tmp


def search(node, g, threshold, path):
    #print("node-state: {}".format(node.state))
    sys.stdout.write("\rg: {}; threshold: {}\n".format(int(g), int(threshold)))
    f = g + h(node)

    if f > threshold:
        return f

    if node.is_terminal():
        return True

    minimum = float('inf')
    for n in node.succ():
        if n not in path:
            path.append(n)  # optimisable
            tmp = search(n, g + node.cost(n), threshold, path)
            if tmp == True:
                return True
            if tmp < minimum:
                minimum = tmp

    return minimum


root = Node()
path, bound = IDA(root)

print("------------------------FIN-------------------------")
print("bound: ", bound)
print(path[-1].hist)
